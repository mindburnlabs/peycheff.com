/**
 * Security Utilities for peycheff.com
 * Provides rate limiting, IP validation, and security monitoring
 */

// Rate limiting storage (in production, use Redis or similar)
const rateLimitStore = new Map()
const securityEventStore = new Map()

// Rate limiting configuration
export const RATE_LIMITS = {
  // API endpoints
  '/api/contact': {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 5, // 5 requests per 15 minutes
    skipSuccessfulRequests: false,
    skipFailedRequests: false
  },
  '/api/checkout': {
    windowMs: 60 * 60 * 1000, // 1 hour
    maxRequests: 10, // 10 requests per hour
    skipSuccessfulRequests: false,
    skipFailedRequests: false
  },
  '/api/analytics': {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 100, // 100 requests per minute
    skipSuccessfulRequests: false,
    skipFailedRequests: false
  },
  '/api/whop': {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 20, // 20 webhooks per minute
    skipSuccessfulRequests: false,
    skipFailedRequests: false
  },
  // Default rate limit for all other API endpoints
  'default': {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: 100, // 100 requests per 15 minutes
    skipSuccessfulRequests: false,
    skipFailedRequests: false
  }
}

// Security event types
export const SECURITY_EVENTS = {
  RATE_LIMIT_EXCEEDED: 'rate_limit_exceeded',
  SUSPICIOUS_REQUEST: 'suspicious_request',
  INVALID_WEBHOOK_SIGNATURE: 'invalid_webhook_signature',
  UNAUTHORIZED_ACCESS: 'unauthorized_access',
  POTENTIAL_XSS: 'potential_xss',
  POTENTIAL_SQL_INJECTION: 'potential_sql_injection',
  ABNORMAL_BEHAVIOR: 'abnormal_behavior',
  BLOCKED_IP: 'blocked_ip'
}

// Suspicious patterns to detect
const SUSPICIOUS_PATTERNS = [
  // SQL injection patterns
  /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/i,
  /(<script|javascript:|onload=|onerror=)/i,
  // XSS patterns
  /(<iframe|<object|<embed|<link|<meta)/i,
  // Path traversal
  /(\.\.[\/\\])/i,
  // Command injection
  /(;|\||&|\$\(|`|wget|curl|nc|netcat)/i,
  // Common attack payloads
  /(base64_encode|base64_decode|eval|exec|system|shell_exec|passthru)/i
]

// Blocked IPs (in production, use a database or Redis)
const BLOCKED_IPS = new Set([
  // Add known malicious IPs here
])

// Rate limiting middleware
interface RateLimitOptions {
  windowMs?: number;
  maxRequests?: number;
  message?: string;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
}

export function createRateLimit(options: RateLimitOptions = {}) {
  const {
    windowMs = 15 * 60 * 1000, // 15 minutes
    maxRequests = 100,
    message = 'Too many requests from this IP, please try again later.',
    skipSuccessfulRequests = false,
    skipFailedRequests = false
  } = options

  return async function rateLimit(req: any) {
    const ip = getClientIP(req)
    const key = `rate_limit:${ip}:${req.url}`
    const now = Date.now()

    // Check if IP is blocked
    if (BLOCKED_IPS.has(ip)) {
      return {
        success: false,
        error: 'Access denied',
        statusCode: 403,
        retryAfter: windowMs
      }
    }

    // Get current request count
    const current = rateLimitStore.get(key) || { count: 0, resetTime: now + windowMs }

    // Reset if window has expired
    if (now > current.resetTime) {
      current.count = 0
      current.resetTime = now + windowMs
    }

    // Increment count
    current.count++
    rateLimitStore.set(key, current)

    // Check if limit exceeded
    if (current.count > maxRequests) {
      await logSecurityEvent({
        type: SECURITY_EVENTS.RATE_LIMIT_EXCEEDED,
        ip,
        url: req.url,
        userAgent: req.headers.get('user-agent'),
        method: req.method,
        count: current.count,
        maxRequests
      })

      return {
        success: false,
        error: message,
        statusCode: 429,
        retryAfter: Math.ceil((current.resetTime - now) / 1000)
      }
    }

    return {
      success: true,
      remaining: Math.max(0, maxRequests - current.count),
      resetTime: current.resetTime
    }
  }
}

// Get client IP address
export function getClientIP(req) {
  return (
    req.headers.get('x-forwarded-for')?.split(',')[0] ||
    req.headers.get('x-real-ip') ||
    req.headers.get('cf-connecting-ip') ||
    '127.0.0.1'
  )
}

// Validate request for suspicious patterns
export function validateRequest(req) {
  const url = req.url
  const userAgent = req.headers.get('user-agent') || ''
  const referer = req.headers.get('referer') || ''
  const ip = getClientIP(req)

  // Check for suspicious patterns in URL and headers
  const allContent = [url, userAgent, referer].join(' ')

  for (const pattern of SUSPICIOUS_PATTERNS) {
    if (pattern.test(allContent)) {
      logSecurityEvent({
        type: SECURITY_EVENTS.SUSPICIOUS_REQUEST,
        ip,
        url,
        userAgent,
        pattern: pattern.source,
        matched: allContent.match(pattern)?.[0]
      })

      return {
        valid: false,
        reason: 'Suspicious content detected',
        pattern: pattern.source
      }
    }
  }

  // Check for missing user agent (often bots)
  if (!userAgent || userAgent.length < 10) {
    logSecurityEvent({
      type: SECURITY_EVENTS.SUSPICIOUS_REQUEST,
      ip,
      url,
      userAgent,
      reason: 'Missing or suspicious user agent'
    })
  }

  // Check for abnormal request methods
  const allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'HEAD', 'PATCH']
  if (!allowedMethods.includes(req.method)) {
    logSecurityEvent({
      type: SECURITY_EVENTS.SUSPICIOUS_REQUEST,
      ip,
      url,
      method: req.method,
      reason: 'Unexpected HTTP method'
    })

    return {
      valid: false,
      reason: 'Method not allowed'
    }
  }

  return { valid: true }
}

// Log security events
export async function logSecurityEvent(eventData) {
  const event = {
    id: `sec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    timestamp: new Date().toISOString(),
    ...eventData
  }

  // Store in memory (in production, use a proper logging system)
  const key = `security_events:${event.type}`
  const events = securityEventStore.get(key) || []
  events.push(event)

  // Keep only last 100 events per type
  if (events.length > 100) {
    events.shift()
  }

  securityEventStore.set(key, events)

  // Log to console for development
  console.warn('ðŸš¨ Security Event:', event)

  // In production, you would:
  // - Send to Sentry/LogRocket
  // - Store in database
  // - Send alerts to security team
  // - Integrate with SIEM systems

  // Auto-block IPs with repeated violations
  if (event.type === SECURITY_EVENTS.RATE_LIMIT_EXCEEDED) {
    const recentEvents = events.filter(e =>
      e.ip === event.ip &&
      (Date.now() - new Date(e.timestamp).getTime()) < 60000 // Last minute
    )

    if (recentEvents.length > 5) {
      BLOCKED_IPS.add(event.ip)
      console.warn(`ðŸš« IP ${event.ip} auto-blocked due to repeated violations`)

      // Log block event
      logSecurityEvent({
        type: SECURITY_EVENTS.BLOCKED_IP,
        ip: event.ip,
        reason: 'Repeated rate limit violations',
        duration: 3600000 // 1 hour
      })
    }
  }

  return event
}

// Get security statistics
export function getSecurityStats() {
  const stats = {
    totalEvents: 0,
    eventsByType: {},
    blockedIPs: BLOCKED_IPS.size,
    rateLimitEntries: rateLimitStore.size,
    recentActivity: []
  }

  // Count events by type
  securityEventStore.forEach((events, key) => {
    const eventType = key.replace('security_events:', '')
    stats.eventsByType[eventType] = events.length
    stats.totalEvents += events.length

    // Get recent activity (last 10 events)
    events.slice(-10).forEach(event => {
      stats.recentActivity.push({
        id: event.id,
        type: event.type,
        timestamp: event.timestamp,
        ip: event.ip
      })
    })
  })

  return stats
}

// Validate webhook signature (for Whop and other webhooks)
export function validateWebhookSignature(payload, signature, secret) {
  if (!signature || !secret) {
    logSecurityEvent({
      type: SECURITY_EVENTS.INVALID_WEBHOOK_SIGNATURE,
      reason: 'Missing signature or secret',
      signature: !!signature,
      secret: !!secret
    })
    return false
  }

  try {
    const crypto = require('crypto')
    const expectedSignature = crypto
      .createHmac('sha256', secret)
      .update(payload, 'utf8')
      .digest('hex')

    const isValid = crypto.timingSafeEqual(
      Buffer.from(signature, 'hex'),
      Buffer.from(expectedSignature, 'hex')
    )

    if (!isValid) {
      logSecurityEvent({
        type: SECURITY_EVENTS.INVALID_WEBHOOK_SIGNATURE,
        reason: 'Signature verification failed',
        providedSignature: signature.substring(0, 20) + '...',
        expectedSignature: expectedSignature.substring(0, 20) + '...'
      })
    }

    return isValid
  } catch (error) {
    logSecurityEvent({
      type: SECURITY_EVENTS.INVALID_WEBHOOK_SIGNATURE,
      reason: 'Error during signature verification',
      error: error.message
    })
    return false
  }
}

// Cleanup old rate limit entries (call this periodically)
export function cleanupRateLimitStore() {
  const now = Date.now()
  let cleaned = 0

  for (const [key, value] of rateLimitStore.entries()) {
    if (now > value.resetTime) {
      rateLimitStore.delete(key)
      cleaned++
    }
  }

  if (cleaned > 0) {
    console.log(`ðŸ§¹ Cleaned ${cleaned} expired rate limit entries`)
  }
}

// Cleanup old security events (call this periodically)
export function cleanupSecurityEvents() {
  const now = Date.now()
  const maxAge = 24 * 60 * 60 * 1000 // 24 hours
  let cleaned = 0

  securityEventStore.forEach((events, key) => {
    const filteredEvents = events.filter(event =>
      (now - new Date(event.timestamp).getTime()) < maxAge
    )

    if (filteredEvents.length !== events.length) {
      securityEventStore.set(key, filteredEvents)
      cleaned += events.length - filteredEvents.length
    }
  })

  if (cleaned > 0) {
    console.log(`ðŸ§¹ Cleaned ${cleaned} old security events`)
  }
}

// Initialize cleanup intervals
if (typeof setInterval !== 'undefined') {
  // Cleanup rate limits every 5 minutes
  setInterval(cleanupRateLimitStore, 5 * 60 * 1000)

  // Cleanup security events every hour
  setInterval(cleanupSecurityEvents, 60 * 60 * 1000)
}

export default {
  createRateLimit,
  getClientIP,
  validateRequest,
  validateWebhookSignature,
  logSecurityEvent,
  getSecurityStats,
  cleanupRateLimitStore,
  cleanupSecurityEvents,
  RATE_LIMITS,
  SECURITY_EVENTS,
  BLOCKED_IPS
}